"""
A policy from TuRBO algorithm for deciding where to sample next.

TODO: if we cannot implement it generally for all types of local surrogates,
     we can consider TuRBO{T} and constraint T to some abstract type
"""
mutable struct TurboPolicy <: Policy
    # for each TR use candidate_size many points to approximate a sample function
    # drawn from the posterior (Thompson sample)
    candidate_size::Int
    prob_of_perturbation::Float64
end

# TODO: allow to configure candidate_size
function TurboPolicy(dimension)
    # default value from the TuRBO paper
    candidate_size = min(100 * dimension, 5000)
    prob_of_perturbation = min(20.0 / dimension, 1)
    TurboPolicy(candidate_size, prob_of_perturbation)
end

# note: policies are callable objects
function (policy::TurboPolicy)(dsm::Turbo)
    next_points = Vector{Vector{Float64}}(undef, dsm.batch_size)
    for i in 1:(dsm.batch_size)
        #    sample a function from the posterior for each TR (discretized version on
        #    candidate_size many points generated by modified Sobol sequence)
        combined_xs = Vector{Vector{Float64}}()
        combined_ys = Vector{Float64}()
        for j in 1:(dsm.n_surrogates)
            tr_xs = turbo_policy_seq(dsm, policy.candidate_size,
                                     policy.prob_of_perturbation, j)
            # calculate approximation function values at tr_xs via the j-th surrogate
            tr_ys = (dsm.surrogates[j]).(tr_xs)
            append!(combined_xs, tr_xs)
            append!(combined_ys, tr_ys)
        end
        next_points[i] = combined_xs[argmax(combined_ys)]
    end
    next_points
end

# TODO: modified Sobol sequence at the intersection of [0,1]^d and j-th TR
function turbo_policy_seq(dsm::Turbo, candidate_size, prob_of_perturbation, j)
    xs = []
    # following the construction from the paper: supplement material part D; and python implementation
    # TODO: scrambled Sobol?
    for perturbation in (from_unit_cube(next!(dsm.sobol_generator), dsm.trs[j].lb,
                                        dsm.trs[j].ub) for _ in 1:candidate_size)
        x = dsm.trs[j].center
        # TODO: use seed for reproducibility?
        # each index is chosen with prob. prob_of_perturbation
        inds = [i for i in 1:length(x) if rand() <= prob_of_perturbation]
        x[inds] = perturbation[inds]
        push!(xs, x)
    end
    xs
end
